// Generated by CoffeeScript 1.6.3
(function() {
  var Entity, assets, engine, root, _ref,
    __slice = [].slice;

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.assets = {};

  engine.assets.loaded = [];

  engine.assets.done = function() {
    if (!engine.assets.progress()) {
      return true;
    } else {
      return false;
    }
  };

  engine.assets.preload = function(assets, cb) {
    var item, _i, _len;
    console.log(assets);
    for (_i = 0, _len = assets.length; _i < _len; _i++) {
      item = assets[_i];
      engine.assets.set(item.id, item.src);
    }
    while (!engine.assets.done) {
      console.log('loading');
    }
    return cb();
  };

  engine.assets.images = {};

  engine.assets.set = function(id, src) {
    var image;
    engine.assets.loaded++;
    image = new Image();
    image.src = src;
    image.onload = function() {
      return engine.assets.loaded--;
    };
    return engine.assets.images[id] = image;
  };

  engine.assets.get = function(id) {
    return engine.assets.images[id];
  };

  engine.assets.done = function() {
    if (engine.assets.done > 0) {
      return false;
    } else {
      return true;
    }
  };

  engine.assets.getJSON = function(file, cb) {
    var xmlhttp;
    xmlhttp = void 0;
    if (window.XMLHttpRequest) {
      xmlhttp = new XMLHttpRequest();
    }
    xmlhttp.onreadystatechange = function() {
      var response;
      if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {
        response = JSON.parse(xmlhttp.responseText);
        return cb(response);
      }
    };
    xmlhttp.open("GET", file, true);
    return xmlhttp.send();
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.init = {};

  engine.init.x = 15;

  engine.init.y = 13;

  engine.init.maps = {};

  engine.init.maps.map1 = {
    src: "data/maps/map1.json",
    first: true
  };

  engine.init.maps.map2 = {
    src: "data/maps/map2.json",
    first: false
  };

  engine.start = function() {
    var key, value;
    engine.setViewport("canvas");
    window.addEventListener("keydown", engine.keyboard.parseInput, false);
    for (key in engine.init.maps) {
      value = engine.init.maps[key];
      engine.map.addMap(key, value.src, value.first);
    }
    return engine.map.setXY(engine.init.x, engine.init.y);
  };

  engine.fullscreen = function() {
    window.addEventListener("touchstart", engine.mobile.startTouch, false);
    window.addEventListener("touchmove", engine.mobile.moveTouch, false);
    window.addEventListener("touchcancel", engine.mobile.stopTouch, false);
    window.addEventListener("touchend", engine.mobile.stopTouch, false);
    window.addEventListener("touchleave", engine.mobile.stopTouch, false);
    window.setInterval(engine.mobile.draw, 50);
    engine.canvas.className = "fullscreen";
    return engine.setFullscreen("canvas");
  };

  engine.nextLevel = function() {
    engine.map.setXY(22, 15);
    engine.map.setMap("map2");
    return engine.draw();
  };

  engine.draw = function() {
    engine.map.draw();
    return engine.player.draw();
  };

  assets = [
    {
      id: "pd1",
      src: "images/entities/thomas/d-1.png"
    }, {
      id: "pd2",
      src: "images/entities/thomas/d-2.png"
    }, {
      id: "pd3",
      src: "images/entities/thomas/d-4.png"
    }, {
      id: "pr1",
      src: "images/entities/thomas/r-1.png"
    }, {
      id: "pr2",
      src: "images/entities/thomas/r-2.png"
    }, {
      id: "pr3",
      src: "images/entities/thomas/r-4.png"
    }, {
      id: "pl1",
      src: "images/entities/thomas/l-1.png"
    }, {
      id: "pl2",
      src: "images/entities/thomas/l-2.png"
    }, {
      id: "pl3",
      src: "images/entities/thomas/l-4.png"
    }, {
      id: "pu1",
      src: "images/entities/thomas/u-1.png"
    }, {
      id: "pu2",
      src: "images/entities/thomas/u-2.png"
    }, {
      id: "pu3",
      src: "images/entities/thomas/u-4.png"
    }, {
      id: "rock",
      src: "images/tiles/rock.png"
    }, {
      id: "grass",
      src: "images/tiles/grass.png"
    }, {
      id: "sand",
      src: "images/tiles/sand.png"
    }, {
      id: "water",
      src: "images/tiles/water.png"
    }, {
      id: "sign",
      src: "images/tiles/sign.png"
    }, {
      id: "blank",
      src: "images/tiles/water.png"
    }
  ];

  window.onload = function() {
    return engine.assets.preload(assets, function() {
      return setTimeout(engine.start, 200);
    });
  };

  window.engine = engine;

  root = typeof window !== "undefined" && window !== null ? window : exports;

  root.engine = (_ref = root.engine) != null ? _ref : {};

  Entity = (function() {
    function Entity(engine) {
      this.engine = engine;
      this.x = 0;
      this.y = 0;
      this.frames = {};
      this.scripts = {};
      this.animations = {};
    }

    Entity.prototype.setXY = function(x, y) {
      this.x = x;
      this.y = y;
    };

    Entity.prototype.addFrame = function(id, sprite) {
      this.frames[id] = sprite;
    };

    Entity.prototype.addScript = function(id, script) {
      this.scripts[id] = script;
    };

    Entity.prototype.move = function(dir) {
      switch (dir) {
        case 'up':
          this.y++;
          break;
        case 'down':
          this.y--;
          break;
        case 'left':
          this.x--;
          break;
        case 'left':
          this.x++;
      }
      if (dir === !'undefined') {
        return this.animate(dir, 0);
      }
    };

    Entity.prototype.currentXY = function() {
      return {
        x: this.x,
        y: this.y
      };
    };

    Entity.prototype.animate = function(id, step) {
      var offsetX, offsetY;
      this.moving = this.animations[id][step].moving;
      offsetX = this.animations[id][step].offsetX;
      offsetY = this.animations[id][step].offsetY;
      this.setCurrentFrame(this.animations[id][step].frame);
      return this.engine.nextStep(this.animate(id, step++));
    };

    Entity.prototype.draw = function() {
      var offsetX, offsetY, x, y;
      x = this.x;
      y = this.y;
      offsetX = this.offsetX;
      offsetY = this.offsetY;
      return this.engine.viewport.draw(x, y, this.getCurrentFrame(), offsetX, offsetY);
    };

    Entity.prototype.setCurrentFrame = function(id) {
      return this.currentFrame = id;
    };

    Entity.prototype.getCurrentFrame = function() {
      return this.currentFrame;
    };

    Entity.prototype.execScript = function() {
      var id, params, _ref1;
      id = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.scripts)[id].apply(_ref1, [this].concat(__slice.call(params)));
    };

    Entity.prototype.buildFromJSON = function(object) {
      var data, frame, frames, script, scripts;
      scripts = object.scripts;
      frames = object.frames;
      for (script in scripts) {
        data = scripts[script];
        this.addScript(script, data);
      }
      for (frame in frames) {
        data = frames[frame];
        this.addFrame(frame, data);
      }
      this.setXY(object.x, object.y);
      if (object.initFrame) {
        return this.setCurrentFrame(object.initFrame);
      }
    };

    return Entity;

  })();

  root.engine.Entity = Entity;

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.keyboard = {};

  engine.keyboard.canInput = true;

  engine.keyboard.getValue = function(key) {
    switch (key) {
      case 38:
        return "up";
      case 40:
        return "down";
      case 37:
        return "left";
      case 39:
        return "right";
      case 65:
        return "a";
    }
  };

  engine.keyboard.parseInput = function(event) {
    var toContine, toContinue;
    if (engine.keyboard.canInput) {
      engine.draw();
      toContinue = true;
      if (engine.keyboard.callback[engine.keyboard.getValue(event.keyCode)]) {
        while (engine.keyboard.callback[engine.keyboard.getValue(event.keyCode)].length > 0) {
          if (engine.keyboard.callback[engine.keyboard.getValue(event.keyCode)].pop()()) {
            toContine = false;
          }
        }
      }
      if (engine.keyboard.callback[engine.keyboard.getValue(event.keyCode)]) {
        while (engine.keyboard.callback.all.length > 0) {
          if (engine.keyboard.callback.all.pop()()) {
            toContinue = false;
          }
        }
      }
      if (!toContinue) {
        return;
      }
      switch (engine.keyboard.getValue(event.keyCode)) {
        case "up":
        case "down":
        case "left":
        case "right":
          engine.player.move(engine.keyboard.getValue(event.keyCode));
          return engine.draw();
        case "a":
          return engine.player.activate();
      }
    }
  };

  engine.keyboard.callbacks = {};

  engine.keyboard.callback = function(key, cb) {
    if (!engine.keyboard.callbacks[key]) {
      engine.keyboard.callbacks[key] = [];
    }
    return engine.keyboard.callbacks[key].push(cb);
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.tile = {};

  engine.tile.images = {};

  engine.map = {};

  engine.map.draw = function() {
    var i, j, mapX, mapY, tile, _results;
    i = void 0;
    j = void 0;
    mapX = 0;
    mapY = 0;
    tile = void 0;
    j = -1;
    _results = [];
    while (j < engine.screen.tilesY + 1) {
      i = -1;
      while (i < engine.screen.tilesX + 1) {
        mapX = i + engine.viewport.x;
        mapY = j + engine.viewport.y;
        tile = engine.map.getTile(mapX, mapY) || ["blank"];
        engine.tile.draw(i, j, tile);
        i++;
      }
      _results.push(j++);
    }
    return _results;
  };

  engine.map.currentMap = null;

  engine.map.setMap = function(id) {
    return engine.map.currentMap = engine.map.avalible[id];
  };

  engine.map.setXY = function(x, y) {
    engine.viewport.x = x;
    return engine.viewport.y = y;
  };

  engine.map.getTile = function(x, y) {
    if (engine.map.currentMap.tiles[y] && engine.map.currentMap.tiles[y][x]) {
      return engine.map.currentMap.tiles[y][x];
    } else {
      return undefined;
    }
  };

  engine.map.getObject = function(x, y) {
    if (engine.map.currentMap.objects[y] && engine.map.currentMap.objects[y][x]) {
      return engine.map.currentMap.objects[y][x];
    } else {
      return undefined;
    }
  };

  engine.tile = {};

  engine.tile.offsetX = 0;

  engine.tile.offsetY = 0;

  engine.tile.draw = function(x, y, tile) {
    var rx, ry;
    rx = x * 16 + engine.tile.offsetX;
    ry = y * 16 + engine.tile.offsetY;
    return tile.forEach(function(tile) {
      if (tile === " ") {
        return;
      }
      return engine.handle.drawImage(engine.assets.get(tile), 0, 0, 32, 32, rx, ry, 16, 16);
    });
  };

  engine.map.avalible = {};

  engine.map.addMap = function(id, src, launch) {
    return engine.assets.getJSON(src, function(response) {
      engine.map.avalible[id] = response;
      if (launch) {
        engine.map.setMap(id);
        return engine.draw();
      }
    });
  };

  engine.map.preload = function(file) {
    engine.assets.loaded++;
    return engine.assets.getJSON(file, function(maps) {
      var map, _i, _len;
      for (_i = 0, _len = maps.length; _i < _len; _i++) {
        map = maps[_i];
        engine.map.addMap(map.id, map.src, map.init);
      }
      return engine.assets.loaded--;
    });
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.mobile = {};

  engine.mobile.touches = {};

  engine.mobile.pad = {};

  engine.mobile.startTouch = function(event) {
    var touch;
    if (!engine.mobile.pad.active) {
      engine.mobile.pad.start = Date.now();
      touch = event.touches[0];
      engine.mobile.pad.x = touch.clientX;
      engine.mobile.pad.y = touch.clientY;
      engine.mobile.pad.active = true;
      return engine.mobile.pad.move = "";
    } else {
      return engine.player.activate();
    }
  };

  engine.mobile.moveTouch = function(event) {
    var touch, x, y;
    event.preventDefault();
    touch = event.touches[0];
    x = touch.clientX - engine.mobile.pad.x;
    y = touch.clientY - engine.mobile.pad.y;
    if (engine.mobile.pad.active) {
      if (Math.abs(x) > Math.abs(y)) {
        if (x < 0) {
          return engine.mobile.pad.move = "left";
        } else {
          return engine.mobile.pad.move = "right";
        }
      } else {
        if (y < 0) {
          return engine.mobile.pad.move = "up";
        } else {
          return engine.mobile.pad.move = "down";
        }
      }
    }
  };

  engine.mobile.stopTouch = function(event) {
    if (event.changedTouches[0].identifier === 0) {
      if (engine.mobile.pad.start > Date.now() - 500) {
        engine.player.activate();
      }
      return engine.mobile.pad.active = false;
    }
  };

  engine.mobile.draw = function() {
    if (engine.mobile.pad.active ? engine.keyboard.canInput : void 0) {
      return engine.player.move(engine.mobile.pad.move);
    }
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.player = {};

  engine.player.assets = ["pd1", "pd2", "pd3", "pr1", "pr2", "pr3", "pu1", "pu2", "pu3", "pl1", "pl2", "pl3"];

  engine.player.spriteIndex = 0;

  engine.player.offsetX = 0;

  engine.player.offsetY = 0;

  engine.player.leftLeg = false;

  engine.player.activate = function() {
    var x, y;
    x = engine.viewport.x + (engine.screen.tilesX / 2 - 0.5);
    y = engine.viewport.y + (engine.screen.tilesY / 2 - 0.5);
    switch (engine.player.spriteIndex) {
      case 6:
        y--;
        break;
      case 3:
        x++;
        break;
      case 0:
        y++;
        break;
      case 9:
        x--;
    }
    if (engine.map.currentMap.objects[y] && engine.map.currentMap.objects[y][x] && engine.map.currentMap.objects[y][x].toCall !== undefined) {
      return engine.scripts.call[engine.map.currentMap.objects[y][x].toCall](engine.map.currentMap.objects[y][x]);
    }
  };

  engine.player.calcLoc = function() {
    var character, x, y;
    character = {
      width: Math.ceil(engine.assets.get(engine.player.assets[0]).width),
      height: Math.ceil(engine.assets.get(engine.player.assets[0]).height)
    };
    x = (engine.screen.width / 2) - (character.width / 2);
    y = (engine.screen.height / 2) + 8 - character.height;
    return {
      left: x,
      top: y
    };
  };

  engine.player.draw = function() {
    var loc;
    loc = engine.player.calcLoc();
    return engine.handle.drawImage(engine.assets.get(engine.player.assets[engine.player.spriteIndex]), loc.left, loc.top);
  };

  engine.player.move = function(direction) {
    var cancel, index, toX, toY, x, y;
    if (!direction) {
      return;
    }
    if (engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4) && engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4).beforeStep) {
      cancel = engine.scripts.call[engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4).beforeStep](direction, engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4));
      if (cancel) {
        return;
      }
    }
    index = void 0;
    x = void 0;
    y = void 0;
    index = x = y = 0;
    engine.keyboard.canInput = false;
    switch (direction) {
      case "up":
        index = 6;
        y = 1;
        break;
      case "right":
        index = 3;
        x = -1;
        break;
      case "left":
        index = 9;
        x = 1;
        break;
      case "down":
        index = 0;
        y = -1;
    }
    if (engine.player.spriteIndex !== index) {
      engine.player.spriteIndex = index;
      engine.keyboard.canInput = true;
      return;
    }
    toX = engine.viewport.x + (engine.screen.tilesX / 2 - 0.5) - x;
    toY = engine.viewport.y + (engine.screen.tilesY / 2 - 0.5) - y;
    if (engine.map.currentMap.objects[toY] && engine.map.currentMap.objects[toY][toX] && engine.map.currentMap.objects[toY][toX].block) {
      engine.keyboard.canInput = true;
    } else {
      engine.tile.offsetX = x * 5;
      engine.tile.offsetY = y * 5;
      setTimeout(engine.player.animate, 100);
      setTimeout(engine.player.reset, 200);
    }
    engine.player.spriteIndex = index;
    engine.draw();
    if (engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4) && engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4).afterStep) {
      cancel = engine.scripts.call[engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4).afterStep](direction, engine.map.getObject(engine.viewport.x + 4, engine.viewport.y + 4));
      if (cancel) {

      }
    }
  };

  engine.player.animate = function() {
    var x, y;
    x = void 0;
    y = void 0;
    x = y = 0;
    switch (engine.player.spriteIndex) {
      case 6:
        y = 11;
        break;
      case 3:
        x = -11;
        break;
      case 9:
        x = 11;
        break;
      case 0:
        y = -11;
    }
    engine.player.spriteIndex += (engine.player.leftLeg ? 1 : 2);
    engine.player.leftLeg = !engine.player.leftLeg;
    engine.tile.offsetX = x;
    engine.tile.offsetY = y;
    return engine.draw();
  };

  engine.player.reset = function() {
    var index, x, y;
    index = void 0;
    x = void 0;
    y = void 0;
    x = engine.viewport.x;
    y = engine.viewport.y;
    index = 0;
    switch (engine.player.spriteIndex) {
      case 7:
      case 8:
        y--;
        index = 6;
        break;
      case 4:
      case 5:
        x++;
        index = 3;
        break;
      case 1:
      case 2:
        y++;
        index = 0;
        break;
      case 10:
      case 11:
        x--;
        index = 9;
    }
    engine.viewport.x = x;
    engine.viewport.y = y;
    engine.keyboard.canInput = true;
    engine.tile.offsetX = 0;
    engine.tile.offsetY = 0;
    engine.player.spriteIndex = index;
    return engine.draw();
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.scripts = {};

  engine.scripts.call = {
    tell: function(object) {
      return engine.viewport.drawMessage(object.text, function() {
        return engine.draw();
      });
    },
    nextlevel: function(object) {
      return engine.nextLevel();
    },
    transition: function(dir, object) {
      if (object.direction === dir) {
        engine.map.setMap(object.map);
        engine.map.setXY(parseInt(object.x), parseInt(object.y));
        engine.draw();
        return true;
      }
    }
  };

  engine = (typeof engine === "undefined" ? {} : engine);

  engine.screen = {};

  engine.setViewport = function(id) {
    engine.canvas = document.getElementById(id);
    engine.handle = engine.canvas.getContext("2d");
    engine.screen.width = engine.canvas.width;
    engine.screen.height = engine.canvas.height;
    engine.screen.tilesX = engine.canvas.width / 16;
    return engine.screen.tilesY = engine.canvas.height / 16;
  };

  engine.setFullscreen = function(id) {
    var elem;
    elem = document.getElementById(id);
    if (elem.requestFullscreen) {
      return elem.requestFullscreen();
    } else if (elem.mozRequestFullScreen) {
      elem = document.getElementById("wrapper");
      return console.log(elem.mozRequestFullScreen());
    } else {
      if (elem.webkitRequestFullscreen) {
        return elem.webkitRequestFullscreen();
      }
    }
  };

  engine.viewport = {};

  engine.viewport.x = 0;

  engine.viewport.y = 0;

  engine.viewport.wrapText = function(context, text, x, y, maxWidth, lineHeight) {
    var i, line, metrics, testLine, testWidth, word, words, _i, _len;
    words = text.split(' ');
    line = '';
    console.log(words);
    for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
      word = words[i];
      testLine = line + word + ' ';
      metrics = context.measureText(testLine);
      testWidth = metrics.width;
      if (testWidth > maxWidth && i > 0) {
        context.strokeText(line, x, y);
        line = word + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    return context.strokeText(line, x, y);
  };

  engine.viewport.drawMessage = function(text, cb) {
    engine.handle.beginPath();
    engine.handle.rect(0, engine.screen.height * 2 / 3, engine.screen.width, engine.screen.height / 3);
    engine.handle.fillStyle = 'white';
    engine.handle.fill();
    engine.handle.linewidth = 7;
    engine.handle.strokeStyle = 'black';
    engine.handle.stroke();
    engine.handle.fillStyle = 'black';
    engine.handle.font = "7px sans-serif";
    engine.viewport.wrapText(engine.handle, text, 8, engine.screen.height * 2 / 3 + 10, engine.screen.width - 16, 10);
    return engine.keyboard.callback("a", cb);
  };

}).call(this);
