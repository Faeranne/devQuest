// Generated by CoffeeScript 1.6.3
(function() {
  var AssetEngine, AudioEngine, ImageEngine, MapEngine, TileEngine, ViewportEngine,
    __slice = [].slice;

  AssetEngine = function(engine) {
    var assets;
    assets = this;
    this.loaded = 0;
    this.toLoad = 0;
    this.engine = engine;
    this.events = new Eventjs('loaded', 'update');
    this.assetLoader = {};
    this.addAssetLoader = function(type, fn) {
      return assets.assetLoader[type] = fn;
    };
    this.loadAsset = function(type, id, src) {
      console.log("getting asset type " + type);
      return assets.assetLoader[type](id, src);
    };
    this.getJson = function(src, cb) {
      var request;
      assets.toLoad++;
      console.log(src);
      request = new XMLHttpRequest();
      request.onload = function() {
        assets.loaded++;
        console.log(this.responseText);
        return cb(JSON.parse(this.responseText));
      };
      request.open("get", src, true);
      return request.send();
    };
    this.getAsset = function(type, id) {
      return assets.assets[type][id];
    };
    this.events.on('update', function() {
      if (this.toLoad === this.loaded) {
        return assets.events.trigger('loaded');
      }
    });
    this.loadAll = function(src) {
      return assets.getJson(src, function(stuff) {
        var asset, assetSet, type, _results;
        console.log(stuff);
        _results = [];
        for (type in stuff) {
          assetSet = stuff[type];
          console.log(assetSet);
          console.log(type);
          if (assets.assetLoader[type]) {
            console.log("loading asset");
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = assetSet.length; _i < _len; _i++) {
                asset = assetSet[_i];
                _results1.push(assets.loadAsset(type, asset.id, asset.src));
              }
              return _results1;
            })());
          } else {
            _results.push(console.warning('couldn\'t load asset type: ' + type + '.  No loader defined'));
          }
        }
        return _results;
      });
    };
    return this;
  };

  AudioEngine = function(engine) {
    var audioEng;
    audioEng = this;
    this.engine = engine;
    this.audio = {};
    this.addAudio = function(id, src) {
      var audio;
      audioEng.engine.assets.toLoad++;
      audio = new Howl({
        urls: [src]
      });
      audio.onload(function() {
        audioEng.engine.assets.loaded++;
        return audioEng.engine.assets.events.trigger('update');
      });
      return audioEng.audio[id] = audio;
    };
    audioEng.engine.assets.addAssetLoader("audio", this.addAudio);
    console.log(this);
    return this;
  };

  ImageEngine = function(engine) {
    var imageEng;
    imageEng = this;
    this.engine = engine;
    this.images = {};
    this.addImage = function(id, src) {
      var image;
      console.log("adding " + id + " from " + src);
      imageEng.engine.assets.toLoad++;
      image = new Image();
      image.src = src;
      image.onload = function() {
        imageEng.engine.assets.loaded++;
        return imageEng.engine.assets.events.trigger('update');
      };
      return imageEng.images[id] = image;
    };
    this.getImage = function(id) {
      return imageEng.images[id];
    };
    this.engine.assets.addAssetLoader("images", this.addImage);
    return this;
  };

  MapEngine = function(engine) {
    var mapEngine;
    mapEngine = this;
    this.engine = engine;
    this.maps = {};
    this.currentMap = '';
    this.x = 0;
    this.y = 0;
    this.setMap = function(id) {
      return mapEngine.currentMap = id;
    };
    this.drawBottomMap = function() {
      var layer, _i, _len, _ref, _results;
      _ref = mapEngine.maps[mapEngine.currentMap].bottomLayer;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push(mapEngine.drawMapLayer(mapEngine.currentMap, layer, 0, 0));
      }
      return _results;
    };
    this.engine.viewport.setDrawSequence(0, this.drawBottomMap);
    this.drawMapLayer = function(map, layer, x, y) {
      var col, image, row, tile, _i, _ref, _results;
      _results = [];
      for (row = _i = 0, _ref = mapEngine.engine.viewport.height; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (col = _j = 0, _ref1 = mapEngine.engine.viewport.width; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
            if (mapEngine.engine.checkObject(layer, row + y, col + x)) {
              tile = layer[row + y][col + x];
              console.log(tile);
              image = mapEngine.engine.tiles.getTile(map.tileset, tile);
              console.log("drawing layer");
              _results1.push(mapEngine.engine.viewport.drawImage(image, mapEngine.engine.viewport.xyToViewport(col + x), mapEngine.engine.viewport.xyToViewport(row + y)));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    this.addMap = function(id, src) {
      return mapEngine.engine.assets.getJson(src, function(map) {
        return mapEngine.maps[id] = map;
      });
    };
    this.engine.assets.addAssetLoader("maps", this.addMap);
    return this;
  };

  TileEngine = function(engine) {
    var tiles;
    tiles = this;
    this.engine = engine;
    this.sets = {};
    this.setSet = function(id, src) {
      var set;
      return set = tiles.engine.assets.getJson(src, function(data) {
        return tiles.sets[id] = set;
      });
    };
    this.getSet = function(id) {
      return tiles.sets[id];
    };
    this.getTile = function(setId, tileId) {
      var image, set, tile;
      console.log('got tile');
      set = tiles.getSet(setId);
      tile = set[tileId];
      image = tiles.engine.images.getImage(set.imageId);
      return {
        image: image,
        sx: tile.x,
        sy: tile.y,
        sw: tile.w,
        sh: tile.h
      };
    };
    this.addTileSet = function(id, src) {
      return tiles.engine.assets.getJson(src, function(set) {
        return tiles.sets[id] = set;
      });
    };
    this.engine.assets.addAssetLoader("tileSet", this.addTileSet);
    return this;
  };

  ViewportEngine = function(engine, canvasId) {
    var viewport;
    viewport = this;
    this.engine = engine;
    this.canvas = document.getElementById(canvasId);
    this.handle = this.canvas.getContext('2d');
    this.toDraw = [];
    this.drawSequence = [];
    this.width = this.canvas.width;
    this.height = this.canvas.height;
    this.drawImage = function(image, x, y) {
      return this.handle.drawImage(image.output, image.sx, image.sy, image.sw, image.sh, x, y, image.sw, image.sh);
    };
    this.addDrawImage = function(image, x, y) {
      var toDraw;
      toDraw = {
        image: image,
        x: x,
        y: y
      };
      return viewport.toDraw.push(toDraw);
    };
    this.setDrawSequence = function(loc, fn) {
      return viewport.drawSequence[loc] = fn;
    };
    this.draw = function() {
      var fn, image, _i, _j, _len, _len1, _ref, _ref1;
      console.log("drawing new frame");
      _ref = viewport.drawSequence;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        console.log(fn);
        fn();
      }
      console.log("rendering to canvas");
      _ref1 = viewport.toDraw;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        image = _ref1[_j];
        viewport.drawImage(image.image, image.x, image.y);
      }
      return viewport.toDraw.length = 0;
    };
    this.engine.events.on('draw', this.draw);
    return this;
  };

  window.onload = function() {
    var engine;
    engine = {
      events: new Eventjs('draw', 'key', 'step'),
      settings: {
        width: 32,
        height: 32
      }
    };
    engine.assets = new AssetEngine(engine);
    engine.viewport = new ViewportEngine(engine, 'viewport');
    engine.images = new ImageEngine(engine);
    engine.audio = new AudioEngine(engine);
    engine.map = new MapEngine(engine);
    engine.tiles = new TileEngine(engine);
    engine.checkObject = function() {
      var check, input, param, valid;
      input = arguments[0], param = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      valid = true;
      check = function() {
        var input, param, toCheck, valid;
        valid = arguments[0], input = arguments[1], param = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        toCheck = param.shift();
        if (input[toCheck]) {
          if (param.length > 0) {
            return check.apply(null, [valid, input[toCheck]].concat(__slice.call(param)));
          }
        } else {
          return valid = false;
        }
      };
      check.apply(null, [valid, input].concat(__slice.call(param)));
      return valid;
    };
    engine.assets.loadAll('data/assets.json');
    engine.loop = function() {
      engine.events.trigger('step');
      engine.events.trigger('draw');
      return window.requestAnimationFrame(engine.loop);
    };
    engine.startLoop = function() {
      return window.requestAnimationFrame(engine.loop);
    };
    return window.engine = engine;
  };

}).call(this);
